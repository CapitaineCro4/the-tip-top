name: CI/CD Pipeline with Backup and Deploy

on:
  push:
    branches:
      - develop
      - preprod
      - main
  pull_request:
    branches:
      - develop
      - preprod
      - main
  schedule:
    - cron: "0 0 * * *" # Tous les jours à minuit UTC
  workflow_dispatch: # Permet de déclencher manuellement

jobs:
  # Job pour la CI (build, tests, optimisation)
  ci:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Configuration Node.js pour le Front
      - name: Setup Node.js for Front
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "yarn"
          cache-dependency-path: front/yarn.lock

      # Installation des dépendances Front
      - name: Install Front Dependencies
        working-directory: ./front
        run: |
          yarn install --frozen-lockfile
          yarn add -D prettier terser-webpack-plugin optimize-css-assets-webpack-plugin

      # Configuration Node.js pour l'API
      - name: Setup Node.js for API
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "yarn"
          cache-dependency-path: api/yarn.lock

      # Installation des dépendances API
      - name: Install API Dependencies
        working-directory: ./api
        run: |
          yarn install --frozen-lockfile
          yarn add -D prettier @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint jest @types/jest ts-jest supertest @types/supertest

      # Vérification du formatage et linting Front
      - name: Check Front Format and Lint
        working-directory: ./front
        run: |
          yarn format
          yarn lint
          yarn format:check

      # Vérification du formatage et linting API
      - name: Check API Format and Lint
        working-directory: ./api
        run: |
          yarn format
          yarn lint
          yarn format:check

      # Tests e2e pour API
      - name: Run API e2e Tests
        working-directory: ./api
        run: |
          yarn test:e2e
        env:
          NODE_ENV: test

      # Tests unitaires pour Front
      - name: Run Front Unit Tests
        working-directory: ./front
        run: |
          yarn test --coverage
        env:
          NODE_ENV: test

      # Stocker les rapports de tests
      - name: Store Test Reports
        if: always() # Exécute même en cas d'échec des tests
        uses: actions/upload-artifact@v3
        with:
          name: test-reports
          path: |
            ./api/coverage/
            ./front/coverage/
            ./api/test-results.json
            ./front/test-results.json

      # Installer Docker
      - name: Install Docker
        run: |
          sudo apt-get update
          sudo apt-get install -y ca-certificates curl gnupg
          sudo install -m 0755 -d /etc/apt/keyrings
          curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo tee /etc/apt/keyrings/docker.asc > /dev/null
          sudo chmod a+r /etc/apt/keyrings/docker.asc
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
          sudo apt-get update
          sudo apt-get install -y docker-ce docker-ce-cli containerd.io

      # Installer Docker Compose
      - name: Install Docker Compose
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          docker-compose version

      # Login to Docker Hub
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Créer un fichier .env
      - name: Create env file
        run: |
          echo "API_PORT=3002" >> .env
          echo "DATABASE_URL=postgresql://admin:admin@postgres_db:5432/mydatabase?schema=public" >> .env
          echo "JWT_SECRET=secret" >> .env
          echo "FRONT_PORT=3000" >> .env
          echo "NEXT_PUBLIC_API_URL=https://dsp5-archi-f24a-15m-g4.fr/api" >> .env

      # Build et push des images Docker
      - name: Build and Push API Docker Image
        run: |
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/the-tip-top-api:latest ./api
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/the-tip-top-api:latest

      - name: Build and Push Front Docker Image
        run: |
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/the-tip-top-front:latest ./front
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/the-tip-top-front:latest

  # Job pour les backups quotidiens
  backup:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install dependencies
        run: |
          pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client

      - name: Setup Google Drive credentials
        run: |
          echo "${{ secrets.GOOGLE_DRIVE_CREDENTIALS }}" > credentials.json
          echo "${{ secrets.GOOGLE_DRIVE_TOKEN }}" > token.json

      - name: Create Backup
        run: |
          timestamp=$(date +%Y%m%d_%H%M%S)
          branch=${{ github.ref_name }}
          mkdir -p backups
          BACKUP_DIR=backups/backup_${branch}_${timestamp}
          mkdir -p $BACKUP_DIR
          # Sauvegarde des workflows
          cp -r .github/workflows $BACKUP_DIR/workflows
          # Sauvegarde du code
          cp -r api $BACKUP_DIR/api
          cp -r front $BACKUP_DIR/front
          cp docker-compose.yml $BACKUP_DIR/
          cp .env $BACKUP_DIR/
          # Sauvegarde de la base de données (via SSH sur VPS)
          sshpass -p "${{ secrets.VPS_PASSWORD }}" ssh -o StrictHostKeyChecking=no root@46.202.132.119 << 'EOF'
            cd /root/the-tip-top-app
            docker-compose exec -T postgres_db pg_dump -U admin mydatabase > /tmp/db_backup_${timestamp}.sql
          EOF
          scp root@46.202.132.119:/tmp/db_backup_${timestamp}.sql $BACKUP_DIR/db_backup.sql

      - name: Upload to Google Drive
        run: |
          cat > upload_to_drive.py << 'EOL'
          from google.oauth2.credentials import Credentials
          from googleapiclient.discovery import build
          from googleapiclient.http import MediaFileUpload
          import os
          from datetime import datetime, timedelta

          # Charger les credentials
          creds = Credentials.from_authorized_user_file('token.json', ['https://www.googleapis.com/auth/drive.file'])
          service = build('drive', 'v3', credentials=creds)

          # ID du dossier de backup dans Google Drive
          BACKUP_FOLDER_ID = '${{ secrets.GOOGLE_DRIVE_FOLDER_ID }}'

          # Upload du nouveau backup
          for filename in os.listdir('backups'):
              file_metadata = {'name': filename, 'parents': [BACKUP_FOLDER_ID]}
              media = MediaFileUpload(f'backups/{filename}', resumable=True)
              service.files().create(body=file_metadata, media_body=media, fields='id').execute()

          # Supprimer les backups de plus de 7 jours
          week_ago = datetime.now() - timedelta(days=7)
          results = service.files().list(q=f"'{BACKUP_FOLDER_ID}' in parents", fields="files(id, name, createdTime)").execute()
          for file in results.get('files', []):
              created_time = datetime.strptime(file['createdTime'], '%Y-%m-%dT%H:%M:%S.%fZ')
              if created_time < week_ago:
                  service.files().delete(fileId=file['id']).execute()
          EOL
          python upload_to_drive.py

      - name: Cleanup
        run: |
          rm -f credentials.json token.json
          rm -rf backups/

  # Job pour le déploiement
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install sshpass
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Deploy to Dev
        if: github.ref == 'refs/heads/develop'
        env:
          VPS_HOST: "46.202.132.119"
          VPS_USER: "root"
          VPS_PASSWORD: ${{ secrets.VPS_PASSWORD }}
        run: |
          sshpass -p "$VPS_PASSWORD" ssh -o StrictHostKeyChecking=no $VPS_USER@$VPS_HOST << 'EOF'
            echo "Deploying to dev..."
            cd /root/the-tip-top-app
            git pull origin develop || { echo "Git pull failed"; exit 1; }
            docker rm -f pushgateway prometheus grafana postgres_db api front backup || true
            docker-compose down || { echo "Docker-compose down failed"; exit 1; }
            docker-compose up --build -d || { echo "Docker-compose up failed"; exit 1; }
            echo "Deployment to dev finished!"
          EOF

      - name: Deploy to Preprod
        if: github.ref == 'refs/heads/preprod'
        env:
          VPS_HOST: "46.202.132.119"
          VPS_USER: "root"
          VPS_PASSWORD: ${{ secrets.VPS_PASSWORD }}
        run: |
          sshpass -p "$VPS_PASSWORD" ssh -o StrictHostKeyChecking=no $VPS_USER@$VPS_HOST << 'EOF'
            echo "Deploying to preprod..."
            cd /root/the-tip-top-app
            git pull origin preprod || { echo "Git pull failed"; exit 1; }
            docker rm -f pushgateway prometheus grafana postgres_db api front backup || true
            docker-compose down || { echo "Docker-compose down failed"; exit 1; }
            docker-compose up --build -d || { echo "Docker-compose up failed"; exit 1; }
            echo "Deployment to preprod finished!"
          EOF

      - name: Deploy to Production (Manual Approval)
        if: github.ref == 'refs/heads/main'
        environment: production
        needs: ci
        env:
          VPS_HOST: "46.202.132.119"
          VPS_USER: "root"
          VPS_PASSWORD: ${{ secrets.VPS_PASSWORD }}
        steps:
          - name: Request manual approval
            uses: trstringer/manual-approval@v1
            with:
              secret: ${{ github.token }}
              approvers: CapitaineCro4
              minimum-approvals: 1
              issue-title: "Manual approval required for production deployment"
              issue-body: "Please approve to deploy to production."

          - name: Deploy to Production
            if: success()
            run: |
              sshpass -p "$VPS_PASSWORD" ssh -o StrictHostKeyChecking=no $VPS_USER@$VPS_HOST << 'EOF'
                echo "Deploying to production..."
                cd /root/the-tip-top-app
                git pull origin main || { echo "Git pull failed"; exit 1; }
                docker rm -f pushgateway prometheus grafana postgres_db api front backup || true
                docker-compose down || { echo "Docker-compose down failed"; exit 1; }
                docker-compose up --build -d || { echo "Docker-compose up failed"; exit 1; }
                echo "Deployment to production finished!"
              EOF
